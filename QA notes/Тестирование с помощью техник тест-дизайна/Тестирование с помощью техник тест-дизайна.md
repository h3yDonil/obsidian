**Тест-дизайн** — это важный этап процесса тестирования программного обеспечения, на котором мы проектируем и создаём тест-кейсы, исходя из заранее определённых критериев качества и целей тестирования. Главная задача тест-дизайна — выбрать из большого объёма данных небольшую, но максимально эффективную часть, которая с высокой вероятностью позволит обнаружить те же ошибки, что и полный набор данных. Это значительно облегчает и ускоряет процесс тестирования.

**Основные цели тест-дизайна:**

1. Создать тесты, способные выявить наиболее серьёзные ошибки в ПО.
2. Минимизировать количество тестов, чтобы не тратить ресурсы на излишние проверки.

**Часто используемые техники тест-дизайна:**

- **Тестирование классов эквивалентности:**  
    Здесь мы разбиваем входные данные на классы, в рамках которых приложение обрабатывает данные одинаково или получает одинаковый результат.  
    _Например:_ В форме регистрации есть поле «Возраст» с допустимыми значениями от 18 до 60. Выделяем три класса:
    
    - Возраст меньше 18 (например, 15) — система должна показать ошибку.
    - Возраст от 18 до 60 (например, 25) — система принимает данные.
    - Возраст больше 60 (например, 65) — ошибка.  
        Для проверки достаточно создать по одному тесту из каждого класса.
- **Анализ граничных значений:**  
    Эта техника фокусируется на проверке поведения системы на крайних значениях входных данных — на границах диапазонов.  
    _Например:_ Для поля «Возраст» тестируем значения:
    
    - 17 (на 1 меньше минимального) — ошибка.
    - 18 (минимальное корректное значение) — должно пройти.
    - 19 (на 1 больше минимального) — должно пройти.
    - 59 (на 1 меньше максимального) — должно пройти.
    - 60 (максимальное корректное значение) — должно пройти.
    - 61 (на 1 больше максимального) — ошибка.

---

**Менее распространённые, но тоже полезные техники:**

- **Попарное тестирование (pairwise testing):**  
    Если у вас есть несколько параметров, например, способ оплаты («Карта» или «PayPal») и тип доставки («Курьер» или «Самовывоз»), то попарное тестирование позволяет сократить количество тестов, проверяя все пары значений, но не все возможные комбинации.  
    _Например:_ Вместо 4 тестов (2 способа оплаты × 2 доставки) выбираем минимальный набор, покрывающий все пары:
    
    - Оплата картой + курьер
    - Оплата PayPal + самовывоз
- **Тестирование на основе состояний и переходов:**  
    Если приложение работает с состояниями, например, заказ может быть «Новый», «Оплачен», «Отправлен», «Доставлен», то важно проверить переходы между этими состояниями.  
    _Например:_ Проверяем, что нельзя перейти из «Новый» сразу в «Доставлен» без оплаты и отправки.
    
- **Таблицы принятия решений:**  
    Когда в системе есть сложная логика, зависящая от нескольких условий, составляем таблицу с комбинациями условий и ожидаемыми результатами.  
    _Например:_ Скидка зависит от статуса клиента и суммы покупки:
    
    |Постоянный клиент|Сумма > 1000|Скидка|
    |---|---|---|
    |Да|Да|10%|
    |Да|Нет|5%|
    |Нет|Да|5%|
    |Нет|Нет|0%|
    |Проверяем все варианты.|||
    
- **Доменный анализ:**  
    Если поле принимает значения в большом диапазоне, например, «Количество товаров» от 1 до 1000, делим диапазон на поддиапазоны и выбираем тестовые значения из каждого.  
    _Например:_
    
    - Маленькое количество: 1–10 (тестируем 5)
    - Среднее: 11–500 (тестируем 250)
    - Большое: 501–1000 (тестируем 800)
- **Сценарии использования (Use Case Testing):**  
    Проверяем реальные сценарии работы пользователя с системой.  
    _Например:_ Сценарий «Покупка товара»:
    
    1. Пользователь заходит на сайт
    2. Выбирает товар
    3. Добавляет в корзину
    4. Оформляет заказ
    5. Получает подтверждение  
        Тестируем весь путь целиком, чтобы убедиться, что все шаги работают вместе.